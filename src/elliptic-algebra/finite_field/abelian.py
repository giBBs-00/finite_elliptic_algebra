import math
from utils.helpers import divisors
import cmath
from cmath import tau  # 2 * pi

class AG:
    def __init__(self, *orders):
        # Sort the orders to normalize the group structure (Z/mZ × Z/nZ, with m ≤ n)
        self.orders = tuple(sorted(orders))
        # How many components the group has (1 = cyclic, 2 = product)
        self.rank = len(orders)
        self.order = math.prod(orders)  # Total number of elements in the group

    def generate(self):
        """
        Generate all elements of the group AG(Z/nZ) or AG(Z/mZ × Z/nZ).
        """
        if self.rank == 1:
            # For cyclic group Z/nZ, return elements 0 to n-1
            return [self.AGE(self, i) for i in range(self.order)]

        if self.rank == 2:
            # For product group Z/mZ × Z/nZ, generate all combinations
            a = self.AGE(self, 1, 0)  # Generator for first component
            b = self.AGE(self, 0, 1)  # Generator for second component
            elements = []
            for i in range(self.orders[0]):
                for j in range(self.orders[1]):
                    elements.append(a * i + b * j)
            return elements

        raise NotImplementedError("Rank 3 and higher not supported")

    def subgroups(self):
        """
        Enumerate all distinct subgroups of the abelian group.
        """
        elems = self.generate()
        subgroups = []
        seen = set()

        for g in elems:
            # Generate the subgroup generated by g
            subgroup = [i * g for i in range(g.order)]
            check = frozenset(subgroup)

            if check not in seen:
                seen.add(check)
                subgroups.append(subgroup)

        return subgroups

    def torsion(self, n: int):
        """
        Return all elements of exact order n.
        """
        return [a for a in self.generate() if a.order == n]
    
    def characters(self):
        """
        Returns all characters of the abelian group as functions χ: G → ℂ*
        Each character maps a group element to a root of unity.
        """
        group_elements = self.generate()
        character_functions = []

        # For each character, represented by an element a in G
        for a in group_elements:
            def make_char(a):
                def χ(g):
                    # Pairwise dot product mod order for each coordinate
                    val = 0
                    for ai, gi, ni in zip(a.coords, g.coords, self.orders):
                        val += (ai * gi) / ni
                    return cmath.exp(tau * 1j * val)
                return χ

            character_functions.append(make_char(a))

        return character_functions

    class AGE:
        def __init__(self, group: "AG", *coords):
            self.group = group  # Reference to the parent group
            # The element's coordinates (e.g., (2, 3) in Z/4 × Z/5)
            self.coords = tuple(coords)

            if not isinstance(group, AG):
                raise TypeError(
                    "An abelian group element must live in an abelian group")

        @property
        def order(self):
            """
            Compute the order of the element (the smallest n such that n * element = identity).
            """
            divs = divisors(self.group.order)
            for div in divs:
                # Multiply the element by div and check if it's the identity element
                if div * self == AG.AGE(self.group, 0, 0) or div * self == AG.AGE(self.group, 0):
                    return div

        def __add__(self, other):
            """
            Add two elements modulo their respective component orders.
            """
            if not isinstance(other, AG.AGE):
                raise TypeError("Operands must be in the same Abelian Group")
            return AG.AGE(
                self.group,
                *((a + b) % n for a, b, n in zip(self.coords, other.coords, self.group.orders))
            )

        def __mul__(self, scalar):
            """
            Scalar multiplication (integer * element), reduced mod the group order.
            """
            if not isinstance(scalar, int):
                raise TypeError("Scalar must be an integer")
            return AG.AGE(
                self.group,
                *(((scalar % n) * a) % n for a, n in zip(self.coords, self.group.orders))
            )

        def __rmul__(self, scalar):
            # Support scalar multiplication in reverse (i.e. 3 * element)
            return self.__mul__(scalar)

        def __eq__(self, other):
            # Equality check: same coordinates and same group
            return isinstance(other, AG.AGE) and self.coords == other.coords and self.group.orders == other.group.orders

        def __hash__(self):
            # Allow this object to be used in sets and as dict keys
            return hash(self.coords)

        def __repr__(self):
            # Clean string representation
            if len(self.coords) == 1:
                return f"({self.coords[0]} mod {self.group.orders[0]})"
            else:
                return f"({self.coords[0]} mod {self.group.orders[0]}, {self.coords[1]} mod {self.group.orders[1]})"
